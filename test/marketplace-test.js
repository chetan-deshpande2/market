const { ethers, upgrades } = require("hardhat");
const { expect } = require("chai");
const { formatEther, parseEther } = require("@ethersproject/units");
const { BigNumber } = require("@ethersproject/bignumber");
const { getImplementationAddress } = require("@openzeppelin/upgrades-core");

const provider = ethers.provider;
let snapshotId, snapshotId_1;

let nftCreator, CreatorV1, marketplace, LNMarketplace;
let simpleERC721Deployer,
  simpleERC1155Deployer,
  extendedERC721Deployer,
  extendedERC1155Deployer;
let implementationAddress,
  implementationNFTCreator1,
  implementationMarketplace1;
let NFT721, NFT1155, NFT721_e, NFT1155_e, ERC20;
let NFT721_2981, NFT721_noRoyalty, NFT1155_2981;
let signers,
  owner,
  addr1,
  addr2,
  addr3,
  addr4,
  addr5,
  addr6,
  addr7,
  addr8,
  addr9,
  Admin,
  dummy;
let TIME;
const ORDERS = [];
//ABI
let SimpleERC721ABI, SimpleERC1155ABI, ExtendedERC721ABI, ExtendedERC1155ABI;
const privateKey = "0x" + process.env.PRIVATE_KEY;

let signer;

const marketplaceArgs = [
  "LN Marketplace", //marketplace name
  "1", //version
  250, //marketplace fee (250 = 2.5%)
  10000, //super Admin fee (6000 = 60%)
  "Admin.address",
  9000, //marketplace royalty limit (9000 = 90%)
];

/*
 * Returns split signature, generated by signing typed data by signer
 */
const getSignature = async (signer, ...args) => {
  const order = await toTypedOrder(...args);

  const signedTypedHash = await signer._signTypedData(
    order.domain,
    order.types,
    order.value
  );
  const sig = ethers.utils.splitSignature(signedTypedHash);

  return [sig.v, sig.r, sig.s];
};

/*
 * Convert order data to typed data for signing
 */
const toTypedOrder = async (
  userAddress,
  tokenAddress,
  id,
  quantity,
  listingType,
  paymentTokenAddress,
  valueToPay,
  deadline,
  bundleTokens,
  bundleTokensQuantity,
  salt
) => {
  const domain = {
    chainId: 31337,
    name: "LN Marketplace",
    verifyingContract: marketplace.address,
    version: "1",
  };

  const types = {
    Order: [
      { name: "user", type: "address" },
      { name: "tokenAddress", type: "address" },
      { name: "tokenId", type: "uint256" },
      { name: "quantity", type: "uint256" },
      { name: "listingType", type: "uint256" },
      { name: "paymentToken", type: "address" },
      { name: "value", type: "uint256" },
      { name: "deadline", type: "uint256" },
      { name: "bundleTokens", type: "uint256[]" },
      { name: "bundleTokensQuantity", type: "uint256[]" },
      { name: "salt", type: "uint256" },
    ],
  };

  const value = {
    user: userAddress,
    tokenAddress: tokenAddress,
    tokenId: id,
    quantity: quantity,
    listingType: listingType,
    paymentToken: paymentTokenAddress,
    value: valueToPay,
    deadline: deadline,
    bundleTokens: bundleTokens,
    bundleTokensQuantity: bundleTokensQuantity,
    salt: salt,
  };

  return { domain, types, value };
};
/*
 * Returns hashed typed data, generated with raw data
 */
const getHashedTypedData = async (...args) => {
  const order = await toTypedOrder(...args);

  return ethers.utils._TypedDataEncoder.hash(
    order.domain,
    order.types,
    order.value
  );
};

describe("Initiation", () => {
  it("Snapshot EVM", async () => {
    snapshotId = await provider.send("evm_snapshot");
  });

  it("Defining Generals", async () => {
    [
      owner,
      addr1,
      addr2,
      addr3,
      addr4,
      addr5,
      addr6,
      addr7,
      addr8,
      addr9,
      Admin,
    ] = await ethers.getSigners();
    signers = [
      owner,
      addr1,
      addr2,
      addr3,
      addr4,
      addr5,
      addr6,
      addr7,
      addr8,
      addr9,
    ];
    signer = new ethers.Wallet(privateKey);
    SimpleERC721ABI = (await ethers.getContractFactory("SimpleERC721"))
      .interface;
    SimpleERC1155ABI = (await ethers.getContractFactory("SimpleERC1155"))
      .interface;
    ExtendedERC721ABI = (await ethers.getContractFactory("ExtendedERC721"))
      .interface;
    ExtendedERC1155ABI = (await ethers.getContractFactory("ExtendedERC1155"))
      .interface;

    marketplaceArgs[4] = Admin.address;
  });
});

describe("Deployment", () => {
  it("Should nftCreator (proxy) contract deploy", async () => {
    CreatorV1 = await ethers.getContractFactory("CreatorV1");
    nftCreator = await upgrades.deployProxy(CreatorV1, { kind: "uups" });
    await nftCreator.deployed();
  });
  it("Connecting to nftCreator implementation contract", async () => {
    implementationAddress = await getImplementationAddress(
      ethers.provider,
      nftCreator.address
    );

    implementationNFTCreator1 = new ethers.Contract(
      implementationAddress,
      CreatorV1.interface,
      provider
    );
  });
  it("Initialize nftCreator implementation! Important security stage!", async () => {
    await implementationNFTCreator1.connect(owner).initialize();
    //proxy should be already initialized
    await expect(nftCreator.connect(owner).initialize()).to.be.revertedWith(
      "Initializable: contract is already initialized"
    );
  });
  it("Deploy marketplace", async () => {
    LNMarketplace = await ethers.getContractFactory("LNMarketplace");
    marketplace = await upgrades.deployProxy(LNMarketplace, marketplaceArgs, {
      kind: "uups",
    });
    await marketplace.deployed();
  });
  it("Connecting to marketplace implementation contract", async () => {
    implementationAddress = await getImplementationAddress(
      ethers.provider,
      marketplace.address
    );

    implementationMarketplace1 = new ethers.Contract(
      implementationAddress,
      LNMarketplace.interface,
      provider
    );
  });

  //   it("Initialize marketplace implementation! Important security stage!", async () => {
  //     await implementationMarketplace1
  //       .connect(owner)
  //       .initialize(...marketplaceArgs);
  //     //proxy should be already initialized
  //     await expect(
  //       marketplace.connect(owner).initialize(...marketplaceArgs)
  //     ).to.be.revertedWith("Initializable: contract is already initialized");
  //   });
  it("Deploy ERC20 for payment", async function () {
    const TestERC20 = await ethers.getContractFactory("TestERC20");
    ERC20 = await TestERC20.deploy(parseEther("10000.0"));
    await ERC20.deployed();

    for (let i = 1; i <= 9; i++) {
      await ERC20.transfer(signers[i].address, parseEther("1000.0"));
      expect(formatEther(await ERC20.balanceOf(signers[i].address))).to.equal(
        "1000.0"
      );
    }
  });
});

describe("NFT Deployment", () => {
  it("SimpleERC721Deployer", async () => {
    const SimpleERC721Deployer = await ethers.getContractFactory(
      "SimpleERC721Deployer"
    );
    simpleERC721Deployer = await SimpleERC721Deployer.deploy(
      nftCreator.address //setting creator role
    );
    await simpleERC721Deployer.deployed();
  });

  it("ExtendedERC721Deployer", async () => {
    const ExtendedERC721Deployer = await ethers.getContractFactory(
      "ExtendedERC721Deployer"
    );
    extendedERC721Deployer = await ExtendedERC721Deployer.deploy(
      nftCreator.address //setting creator role
    );
    await extendedERC721Deployer.deployed();
  });

  it("SimpleERC1155Deployer", async () => {
    const SimpleERC1155Deployer = await ethers.getContractFactory(
      "SimpleERC1155Deployer"
    );
    simpleERC1155Deployer = await SimpleERC1155Deployer.deploy(
      nftCreator.address //setting creator role
    );
    await simpleERC1155Deployer.deployed();
  });

  it("ExtendedERC1155Deployer", async () => {
    const ExtendedERC1155Deployer = await ethers.getContractFactory(
      "ExtendedERC1155Deployer"
    );
    extendedERC1155Deployer = await ExtendedERC1155Deployer.deploy(
      nftCreator.address //setting creator role
    );
    await extendedERC1155Deployer.deployed();
  });

  it("Setting deployers", async () => {
    await nftCreator.setMarketplaceAndDeployers(
      marketplace.address,
      simpleERC721Deployer.address,
      extendedERC721Deployer.address,
      simpleERC1155Deployer.address,
      extendedERC1155Deployer.address
    );
  });
});
describe("Preparing ERC721", () => {
  it("Should be able to deploy Simple ERC721", async () => {
    const newNftAddress = await nftCreator
      .connect(addr1)
      .callStatic.deploySimpleERC721("Name", "Symbol", "http://uri.net/", 1000);
    await nftCreator
      .connect(addr1)
      .deploySimpleERC721("Name", "Symbol", "http://uri.net/", 1000);

    NFT721 = new ethers.Contract(newNftAddress, SimpleERC721ABI, provider);

    expect(await NFT721.name()).to.equal("Name");
    expect(await NFT721.symbol()).to.equal("Symbol");
    expect(await NFT721.owner()).to.equal(addr1.address);
    expect(await NFT721.lnMarketplaceAddress()).to.equal(marketplace.address);
  });

  it("Should mint by owner", async () => {
    for (let i = 1; i <= 5; i++) {
      await NFT721.connect(addr1).mint(addr2.address, i);
      expect(await NFT721.tokenURI(i)).to.equal("http://uri.net/" + i);
      expect(await NFT721.ownerOf(i)).to.equal(addr2.address);
    }
    expect(await NFT721.balanceOf(addr2.address)).to.equal(5);
  });

  it("Should be able to deploy Extended ERC721", async () => {
    const newNftAddress = await nftCreator
      .connect(addr1)
      .callStatic.deployExtendedERC721(
        "Name",
        "Symbol",
        "http://uri.net/",
        1000,
        "0x0000000000000000000000000000000000000000"
      );
    await nftCreator
      .connect(addr1)
      .deployExtendedERC721(
        "Name",
        "Symbol",
        "http://uri.net/",
        1000,
        "0x0000000000000000000000000000000000000000"
      );

    NFT721_e = new ethers.Contract(newNftAddress, ExtendedERC721ABI, provider);

    expect(await NFT721_e.name()).to.equal("Name");
    expect(await NFT721_e.symbol()).to.equal("Symbol");
    expect(await NFT721_e.preSalePaymentToken()).to.equal(
      "0x0000000000000000000000000000000000000000"
    );
    expect(await NFT721_e.owner()).to.equal(addr1.address);
    expect(await NFT721_e.lnMarketplaceAddress()).to.equal(marketplace.address);
  });

  it("Should mint by owner", async () => {
    for (let i = 1; i <= 5; i++) {
      await NFT721_e.connect(addr1).mint(addr1.address, i);
      expect(await NFT721_e.tokenURI(i)).to.equal("http://uri.net/" + i);
      expect(await NFT721_e.ownerOf(i)).to.equal(addr1.address);
    }
    expect(await NFT721_e.balanceOf(addr1.address)).to.equal(5);
  });
});

describe("Preparing ERC1155", () => {
  it("Should be able to deploy Simple ERC1155", async function () {
    const newNftAddress = await nftCreator
      .connect(addr3)
      .callStatic.deploySimpleERC1155("http://uri-1155.net/{id}.json", 1000);
    await nftCreator
      .connect(addr3)
      .deploySimpleERC1155("http://uri-1155.net/{id}.json", 1000);

    NFT1155 = new ethers.Contract(newNftAddress, SimpleERC1155ABI, provider);

    expect(await NFT1155.uri(1)).to.equal("http://uri-1155.net/{id}.json");
    expect(await NFT1155.owner()).to.equal(addr3.address);
    expect(await NFT1155.lnMarketplaceAddress()).to.equal(marketplace.address);
  });

  it("Should mint by owner", async function () {
    for (let i = 1; i <= 5; i++) {
      await NFT1155.connect(addr3).mint(addr2.address, i, 50);
      expect(await NFT1155.balanceOf(addr2.address, i)).to.equal(50);
    }
  });

  it("Should be able to deploy Extended ERC1155", async function () {
    const newNftAddress = await nftCreator
      .connect(addr3)
      .callStatic.deployExtendedERC1155(
        "http://uri-1155.net/{id}.json",
        1000,
        ERC20.address
      );
    await nftCreator
      .connect(addr3)
      .deployExtendedERC1155(
        "http://uri-1155.net/{id}.json",
        1000,
        ERC20.address
      );

    NFT1155_e = new ethers.Contract(
      newNftAddress,
      ExtendedERC1155ABI,
      provider,
      ERC20.address
    );

    expect(await NFT1155_e.uri(1)).to.equal("http://uri-1155.net/{id}.json");
    expect(await NFT1155_e.owner()).to.equal(addr3.address);
    expect(await NFT1155_e.preSalePaymentToken()).to.equal(ERC20.address);
    expect(await NFT1155_e.lnMarketplaceAddress()).to.equal(
      marketplace.address
    );
  });

  it("Should mint by owner", async function () {
    for (let i = 1; i <= 5; i++) {
      await NFT1155_e.connect(addr3).mint(addr3.address, i, 50);
      expect(await NFT1155_e.balanceOf(addr3.address, i)).to.equal(50);
    }
  });
});
describe("Buy Now", () => {
  it("Should be able to buy ERC721. Marketing fee and royalty should be distributed", async function () {
    await NFT721.connect(addr2).setApprovalForAll(marketplace.address, true);

    const sellerBalanceBeforeSale = Number(
      formatEther(await provider.getBalance(addr2.address))
    );
    console.log("sellers balance before sale", sellerBalanceBeforeSale);
    const buyerBalanceBeforeSale = Number(
      formatEther(await provider.getBalance(addr4.address))
    );
    const royaltyReceiverBalanceBeforeSale = Number(
      formatEther(await provider.getBalance(addr1.address))
    );
    const marketplaceBalanceBeforeSale = Number(
      formatEther(await provider.getBalance(marketplace.address))
    );

    const TIME = Math.round(new Date() / 1000 + 3600);
    const sellerOrder = [
      addr2.address,
      NFT721.address,
      1,
      1,
      0,
      "0x0000000000000000000000000000000000000000", //ETH
      parseEther("1.0"),
      TIME,
      [],
      [],
      Math.round(Math.random() * 1000),
    ];
    const sellerSig = await getSignature(addr2, ...sellerOrder);

    const buyerOrder = [
      addr4.address,
      NFT721.address,
      1,
      1,
      0,
      "0x0000000000000000000000000000000000000000", //ETH
      parseEther("1.0"),
      TIME,
      [],
      [],
      Math.round(Math.random() * 1000),
    ];

    await marketplace.connect(addr4).completeOrder(
      sellerOrder,
      sellerSig,
      buyerOrder,
      sellerSig, //buyer signature is unnecessary when buy out
      { value: parseEther("1.5") }
    );
    const sellerBalanceAfterSale = Number(
      formatEther(await provider.getBalance(addr2.address))
    );
    const buyerBalanceAfterSale = Number(
      formatEther(await provider.getBalance(addr4.address))
    );
    const royaltyReceiverBalanceAfterSale = Number(
      formatEther(await provider.getBalance(addr1.address))
    );
    const marketplaceBalanceAfterSale = Number(
      formatEther(await provider.getBalance(marketplace.address))
    );

    expect(await NFT721.ownerOf(1)).to.equal(addr4.address);

    expect(sellerBalanceAfterSale - sellerBalanceBeforeSale).to.be.closeTo(
      0.875,
      0.01
    );

    expect(buyerBalanceBeforeSale - buyerBalanceAfterSale).to.be.closeTo(
      1,
      0.01
    );

    expect(
      royaltyReceiverBalanceAfterSale - royaltyReceiverBalanceBeforeSale
    ).to.be.closeTo(0.099, 0.01);

    expect(
      marketplaceBalanceAfterSale - marketplaceBalanceBeforeSale
    ).to.be.closeTo(0.025, 0.001);
  });
  it("Should not be able to buy ERC721 that was already sold", async function () {
    await NFT721.connect(addr2).setApprovalForAll(marketplace.address, true);

    const TIME = Math.round(new Date() / 1000 + 3600);
    const sellerOrder = [
      addr2.address,
      NFT721.address,
      1,
      1,
      0,
      "0x0000000000000000000000000000000000000000", //ETH
      parseEther("1.0"),
      TIME,
      [],
      [],
      Math.round(Math.random() * 1000),
    ];
    const sellerSig = await getSignature(addr2, ...sellerOrder);

    const buyerOrder = [
      addr5.address,
      NFT721.address,
      1,
      1,
      0,
      "0x0000000000000000000000000000000000000000", //ETH
      parseEther("1.0"),
      TIME,
      [],
      [],
      Math.round(Math.random() * 1000),
    ];

    await expect(
      marketplace.connect(addr5).completeOrder(
        sellerOrder,
        sellerSig,
        buyerOrder,
        sellerSig, //buyer signature is unnecessary when buy out
        { value: parseEther("1.5") }
      )
    ).to.be.reverted;
  });

  it("Should be able to resell ERC721", async function () {
    await NFT721.connect(addr4).setApprovalForAll(marketplace.address, true);

    const sellerBalanceBeforeSale = Number(
      formatEther(await provider.getBalance(addr4.address))
    );
    const buyerBalanceBeforeSale = Number(
      formatEther(await provider.getBalance(addr5.address))
    );
    const royaltyReceiverBalanceBeforeSale = Number(
      formatEther(await provider.getBalance(addr1.address))
    );
    const marketplaceBalanceBeforeSale = Number(
      formatEther(await provider.getBalance(marketplace.address))
    );

    const TIME = Math.round(new Date() / 1000 + 3600);
    const sellerOrder = [
      addr4.address,
      NFT721.address,
      1,
      1,
      0,
      "0x0000000000000000000000000000000000000000", //ETH
      parseEther("1.0"),
      TIME,
      [],
      [],
      Math.round(Math.random() * 1000),
    ];
    const sellerSig = await getSignature(addr4, ...sellerOrder);

    const buyerOrder = [
      addr5.address,
      NFT721.address,
      1,
      1,
      0,
      "0x0000000000000000000000000000000000000000", //ETH
      parseEther("1.0"),
      TIME,
      [],
      [],
      Math.round(Math.random() * 1000),
    ];

    await marketplace.connect(addr5).completeOrder(
      sellerOrder,
      sellerSig,
      buyerOrder,
      sellerSig, //buyer signature is unnecessary when buy out
      { value: parseEther("1.0") }
    );

    const sellerBalanceAfterSale = Number(
      formatEther(await provider.getBalance(addr4.address))
    );
    const buyerBalanceAfterSale = Number(
      formatEther(await provider.getBalance(addr5.address))
    );
    const royaltyReceiverBalanceAfterSale = Number(
      formatEther(await provider.getBalance(addr1.address))
    );
    const marketplaceBalanceAfterSale = Number(
      formatEther(await provider.getBalance(marketplace.address))
    );

    expect(await NFT721.ownerOf(1)).to.equal(addr5.address);

    expect(sellerBalanceAfterSale - sellerBalanceBeforeSale).to.be.closeTo(
      0.875,
      0.01
    );
    expect(buyerBalanceBeforeSale - buyerBalanceAfterSale).to.be.closeTo(
      1,
      0.01
    );
    expect(
      royaltyReceiverBalanceAfterSale - royaltyReceiverBalanceBeforeSale
    ).to.be.closeTo(0.099, 0.01);
    expect(
      marketplaceBalanceAfterSale - marketplaceBalanceBeforeSale
    ).to.be.closeTo(0.025, 0.001);
  });

  it("Should be able lazy mint ERC721", async function () {
    await NFT721.connect(addr1).setApprovalForAll(marketplace.address, true);

    const sellerBalanceBeforeSale = Number(
      formatEther(await provider.getBalance(addr1.address))
    );
    const buyerBalanceBeforeSale = Number(
      formatEther(await provider.getBalance(addr4.address))
    );
    const marketplaceBalanceBeforeSale = Number(
      formatEther(await provider.getBalance(marketplace.address))
    );

    const TIME = Math.round(new Date() / 1000 + 3600);
    const sellerOrder = [
      addr1.address,
      NFT721.address,
      6,
      1,
      0,
      "0x0000000000000000000000000000000000000000", //ETH
      parseEther("1.0"),
      TIME,
      [],
      [],
      Math.round(Math.random() * 1000),
    ];
    const sellerSig = await getSignature(addr1, ...sellerOrder);

    const buyerOrder = [
      addr4.address,
      NFT721.address,
      6,
      1,
      0,
      "0x0000000000000000000000000000000000000000", //ETH
      parseEther("1.0"),
      TIME,
      [],
      [],
      Math.round(Math.random() * 1000),
    ];

    await marketplace.connect(addr4).completeOrder(
      sellerOrder,
      sellerSig,
      buyerOrder,
      sellerSig, //buyer signature is unnecessary when buy out
      { value: parseEther("1.0") }
    );

    const sellerBalanceAfterSale = Number(
      formatEther(await provider.getBalance(addr1.address))
    );
    const buyerBalanceAfterSale = Number(
      formatEther(await provider.getBalance(addr4.address))
    );
    const marketplaceBalanceAfterSale = Number(
      formatEther(await provider.getBalance(marketplace.address))
    );

    expect(await NFT721.ownerOf(1)).to.equal(addr5.address);

    expect(sellerBalanceAfterSale - sellerBalanceBeforeSale).to.be.closeTo(
      0.975,
      0.01
    );
    expect(buyerBalanceBeforeSale - buyerBalanceAfterSale).to.be.closeTo(
      1,
      0.01
    );
    expect(
      marketplaceBalanceAfterSale - marketplaceBalanceBeforeSale
    ).to.be.closeTo(0.025, 0.001);
  });

  it("Should be able to buy ERC1155", async function () {
    await NFT1155.connect(addr2).setApprovalForAll(marketplace.address, true);

    const sellerBalanceBeforeSale = Number(
      formatEther(await provider.getBalance(addr2.address))
    );
    const buyerBalanceBeforeSale = Number(
      formatEther(await provider.getBalance(addr4.address))
    );
    const royaltyReceiverBalanceBeforeSale = Number(
      formatEther(await provider.getBalance(addr3.address))
    );
    const marketplaceBalanceBeforeSale = Number(
      formatEther(await provider.getBalance(marketplace.address))
    );

    const TIME = Math.round(new Date() / 1000 + 3600);
    const sellerOrder = [
      addr2.address,
      NFT1155.address,
      1,
      20,
      0,
      "0x0000000000000000000000000000000000000000", //ETH
      parseEther("0.1"),
      TIME,
      [],
      [],
      Math.round(Math.random() * 1000),
    ];
    const sellerSig = await getSignature(addr2, ...sellerOrder);

    const buyerOrder = [
      addr4.address,
      NFT1155.address,
      1,
      10,
      0,
      "0x0000000000000000000000000000000000000000", //ETH
      parseEther("1.0"),
      TIME,
      [],
      [],
      Math.round(Math.random() * 1000),
    ];

    await marketplace.connect(addr4).completeOrder(
      sellerOrder,
      sellerSig,
      buyerOrder,
      sellerSig, //buyer signature is unnecessary when buy out
      { value: parseEther("1.5") }
    );

    const sellerBalanceAfterSale = Number(
      formatEther(await provider.getBalance(addr2.address))
    );
    const buyerBalanceAfterSale = Number(
      formatEther(await provider.getBalance(addr4.address))
    );
    const royaltyReceiverBalanceAfterSale = Number(
      formatEther(await provider.getBalance(addr3.address))
    );
    const marketplaceBalanceAfterSale = Number(
      formatEther(await provider.getBalance(marketplace.address))
    );

    expect(await NFT1155.balanceOf(addr4.address, 1)).to.equal(10);

    expect(sellerBalanceAfterSale - sellerBalanceBeforeSale).to.be.closeTo(
      0.875,
      0.01
    );
    expect(buyerBalanceBeforeSale - buyerBalanceAfterSale).to.be.closeTo(
      1,
      0.01
    );
    expect(
      royaltyReceiverBalanceAfterSale - royaltyReceiverBalanceBeforeSale
    ).to.be.closeTo(0.099, 0.01);
    expect(
      marketplaceBalanceAfterSale - marketplaceBalanceBeforeSale
    ).to.be.closeTo(0.025, 0.001);
  });
});
